<?php


class guardiankey
{

     private $GKconfig;
     

    
    function check_extensions()
    {
        $nook=False;
        $extensions=array("curl");
        
        foreach($extensions as $ext){
            if ( !extension_loaded ($ext) )
            {
                echo "You have to install the PHP extension $ext\n";
                $nook=1;
            }
        }
        if($nook)
            exit;
    }

    function __construct($GKconfig=null)
    {
		$this->GKconfig = array(
                                'agentid' => get_option('gk_agentid'),  /* ID for the agent (your system) */
                                'key' => get_option('gk_key'),     /* Key in B64 to communicate with GuardianKey */
                                'iv' => get_option('gk_iv'),      /* IV in B64 for the key */
                                'service' => get_option('gk_service'),      /* Your service name*/
                                'orgid' => get_option('gk_orgid'),   /* Your Org identification in GuardianKey */
                                'authgroupid' => get_option('gk_authgroupid'), /* A Authentication Group identification, generated by GuardianKey */
                                'reverse' => get_option('dnsreverse') /* If you will locally perform a reverse DNS resolution */
                                );
        $this->check_extensions();
        if($GKconfig!=null)
            $this->GKconfig = $GKconfig;
    }

    function _json_encode($obj)
    {
        array_walk_recursive($obj, function (&$item, $key) {
            $item = utf8_encode($item);
        });
        return json_encode($obj);
    }

    function create_message($username, $useremail="", $attempt = 0, $eventType="Authentication")
    {
        $GKconfig = $this->GKconfig;
        $keyb64 = $GKconfig['key'];
        $ivb64 = $GKconfig['iv'];
        $agentid = $GKconfig['agentid'];
        $orgid = $GKconfig['orgid'];
        $authgroupid = $GKconfig['authgroupid'];
        $reverse = $GKconfig['reverse'];
        $timestamp = time();
        if (strlen($agentid) > 0) {
            $key = base64_decode($keyb64);
            $iv = base64_decode($ivb64);

            $json = new stdClass();
            $json->generatedTime = $timestamp;
            $json->agentId = $agentid;
            $json->organizationId = $orgid;
            $json->authGroupId = $authgroupid;
            $json->service = $GKconfig['service'];
            $json->clientIP = $_SERVER['REMOTE_ADDR'];
            $json->clientReverse = ($reverse == "True") ? gethostbyaddr($json->clientIP) : "";
            $json->userName = $username;
            $json->authMethod = "";
            $json->loginFailed = $attempt;
            $json->userAgent = substr($_SERVER['HTTP_USER_AGENT'], 0, 500);
            $json->psychometricTyped = "";
            $json->psychometricImage = "";
            $json->event_type=$eventType; // "Authentication" "Bad access"  ou "Registration"
            $json->userEmail=$useremail;
            $tmpmessage = $this->_json_encode($json);
            $blocksize = 8;
            $padsize = $blocksize - (strlen($tmpmessage) % $blocksize);
            $message = str_pad($tmpmessage, $padsize, " ");
            $cipher = openssl_encrypt($message, 'aes-256-cfb8', $key, 0, $iv);
            return $cipher;
        }
    }

    function sendevent($username, $useremail="", $attempt = "0", $eventType = 'Authentication')
    {
        $GKconfig = $this->GKconfig;
		$guardianKeyWS = 'https://api.guardiankey.io/sendevent';
        $message = $this->create_message($username, $useremail, $attempt, $eventType);
		$tmpdata = new stdClass();
        $tmpdata->id = $GKconfig['authgroupid'];
        $tmpdata->message = $message;
		$data = $this->_json_encode($tmpdata);
		$response = wp_remote_post( $guardianKeyWS, array(
			'method' => 'POST',
			'timeout' => 45,
			'redirection' => 5,
			'httpversion' => '1.0',
			'blocking' => true,
			'headers' => array('Content-Type' => 'application/json'),
			'body' => $data
			)
		);
    }

    function checkaccess($username, $useremail="", $attempt = "0", $eventType = 'Authentication')
    {
        $GKconfig = $this->GKconfig;
        $guardianKeyWS = 'https://api.guardiankey.io/checkaccess';
        $message = $this->create_message($username, $useremail, $attempt, $eventType);
        $tmpdata = new stdClass();
        $tmpdata->id = $GKconfig['authgroupid'];
        $tmpdata->message = $message;
        $data = $this->_json_encode($tmpdata);
		$response = wp_remote_post( $guardianKeyWS, array(
			'method' => 'POST',
			'timeout' => 45,
			'redirection' => 5,
			'httpversion' => '1.0',
			'blocking' => true,
			'headers' => array('Content-Type' => 'application/json'),
			'body' => $data
			)
		);
        
        try {
            $foo = json_decode($response['body']);
            return $response['body'];
        } catch (Exception $e) {
            return '{"response":"ERROR"}';
        }
    }
    
    /*
     * Optionally, you can set the notification parameters, such as:
     *   - notify_method: email or webhook
     *   - notify_data: A base64-encoded json containing URL (if method is webhook), server and SMTP port, user, and email password.
     * Example for e-mail:
     * $notify_method = 'email';
     * $notify_data = base64_encode('{"smtp_method":"TLS","smtp_host":"smtp.example.foo","smtp_port":"587","smtp_user":"myuser","smtp_pass":"mypass"}');
     * Example for webhook:
     * $notify_method = 'webhook';
     * $notify_data = base64_encode('{"webhook_url":"https://myorganization.com/guardiankey.php"}');
     */
    function register($email, $notify_method = null, $notify_data_json = null)
    {
        $guardianKeyWS = 'https://api.guardiankey.io/register';
        // Create new Key
        $key = openssl_random_pseudo_bytes(32);
        $iv = openssl_random_pseudo_bytes(16);
        $agentid = sha1(base64_encode(openssl_random_pseudo_bytes(20)));
        $keyb64 = base64_encode($key);
        $ivb64 = base64_encode($iv);

        $data = array(
            'email' => $email,
            'keyb64' => $keyb64,
            'ivb64' => $ivb64
        );
        
        if($notify_method!=null && $notify_data_json!=null)
        {
            $data = array(
                'email' => $email,
                'keyb64' => $keyb64,
                'ivb64' => $ivb64,
                'notify_method' => $notify_method,
                'notify_data' => $notify_data_json
            );
        }
        
        $returned = wp_remote_post( $guardianKeyWS, array(
			'method' => 'POST',
			'timeout' => 45,
			'redirection' => 5,
			'httpversion' => '1.0',
			'blocking' => true,
			'body' => $data
				)
			);
        
        $returns = @json_decode($returned['body']);
        if ($returns === null) {
            return 'An error ocurred: ' . $returned['body'];
        } else {
            return array(   "email"=> $email,
                            "agentid"=> $agentid,
                            "key"=>$keyb64,
                            "iv"=>$ivb64,
                            "orgid"=>$returns->organizationId,
                            "groupid"=>$returns->authGroupId
                        );
        }
    }
    
    function processWebHookPost($authgroupid=null,$keyb64=null,$ivb64=null)
    {
        
        if($authgroupid==null){
            $GKconfig = $this->GKconfig;
            $keyb64 = $GKconfig['key'];
            $ivb64 = $GKconfig['iv'];
            $authgroupid = $GKconfig['authgroupid'];
        }
        
        $data['authGroupId'] = sanitize_text_field($_POST['authGroupId']);
        $data['data'] = sanitize_text_field($_POST['data']);
        
        if ($data['authGroupId'] == $authgroupid ) {
            $key = base64_decode($keyb64);
            $iv  = base64_decode($ivb64);
            try {
                $msgcrypt = base64_decode($data['data']);
                $output = openssl_decrypt($msgcrypt, 'aes-256-cfb8', $key, 1, $iv);
                $dataReturn=json_decode($output,true);
            } catch (Exception $e) {
                throw $e; // 'Error decrypting: ',  $e->getMessage(), "\n";
            }
            
            return $dataReturn;
            
        }   
    }
}
?>
